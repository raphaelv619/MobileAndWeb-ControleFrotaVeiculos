{"ast":null,"code":"/** @license React v16.12.0\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var ReactDOM = require('react-dom');\n\n    var _assign = require('object-assign');\n\n    {\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n      }\n    }\n\n    var warningWithoutStack = function warningWithoutStack() {};\n\n    {\n      warningWithoutStack = function warningWithoutStack(condition, format) {\n        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var argsWithFormat = args.map(function (item) {\n            return '' + item;\n          });\n          argsWithFormat.unshift('Warning: ' + format);\n          Function.prototype.apply.call(console.error, console, argsWithFormat);\n        }\n\n        try {\n          var argIndex = 0;\n          var message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n    var getFiberCurrentPropsFromNode$1 = null;\n    var getInstanceFromNode$1 = null;\n    var getNodeFromInstance$1 = null;\n\n    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n      getFiberCurrentPropsFromNode$1 = getFiberCurrentPropsFromNodeImpl;\n      getInstanceFromNode$1 = getInstanceFromNodeImpl;\n      getNodeFromInstance$1 = getNodeFromInstanceImpl;\n      {\n        !(getNodeFromInstance$1 && getInstanceFromNode$1) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n      }\n    }\n\n    var validateEventDispatches;\n    {\n      validateEventDispatches = function validateEventDispatches(event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n      };\n    }\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          }\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n\n      return null;\n    }\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n\n      if (!!Array.isArray(dispatchListener)) {\n        {\n          throw Error(\"executeDirectDispatch(...): Invalid `event`.\");\n        }\n      }\n\n      event.currentTarget = dispatchListener ? getNodeFromInstance$1(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    }\n\n    var HostComponent = 5;\n\n    function getParent(inst) {\n      do {\n        inst = inst.return;\n      } while (inst && inst.tag !== HostComponent);\n\n      if (inst) {\n        return inst;\n      }\n\n      return null;\n    }\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      }\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      }\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      }\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n\n        instB = getParent(instB);\n      }\n\n      return false;\n    }\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n\n    function accumulateInto(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulateInto(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n\n    function getListener(inst, registrationName) {\n      var listener;\n      var stateNode = inst.stateNode;\n\n      if (!stateNode) {\n        return null;\n      }\n\n      var props = getFiberCurrentPropsFromNode$1(stateNode);\n\n      if (!props) {\n        return null;\n      }\n\n      listener = props[registrationName];\n\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n\n      if (!(!listener || typeof listener === 'function')) {\n        {\n          throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + _typeof(listener) + \"` type.\");\n        }\n      }\n\n      return listener;\n    }\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n\n    var EVENT_POOL_SIZE = 10;\n    var EventInterface = {\n      type: null,\n      target: null,\n      currentTarget: function currentTarget() {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function timeStamp(event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n\n    function functionThatReturnsTrue() {\n      return true;\n    }\n\n    function functionThatReturnsFalse() {\n      return false;\n    }\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName];\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function preventDefault() {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function stopPropagation() {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n      persist: function persist() {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n      isPersistent: functionThatReturnsFalse,\n      destructor: function destructor() {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n          Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n\n      var E = function E() {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n\n    addEventPoolingTo(SyntheticEvent);\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n\n      if (!(event instanceof EventConstructor)) {\n        {\n          throw Error(\"Trying to release an event instance into a pool of a different type.\");\n        }\n      }\n\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n\n    var ResponderSyntheticEvent = SyntheticEvent.extend({\n      touchHistory: function touchHistory(nativeEvent) {\n        return null;\n      }\n    });\n    var TOP_TOUCH_START = 'touchstart';\n    var TOP_TOUCH_MOVE = 'touchmove';\n    var TOP_TOUCH_END = 'touchend';\n    var TOP_TOUCH_CANCEL = 'touchcancel';\n    var TOP_SCROLL = 'scroll';\n    var TOP_SELECTION_CHANGE = 'selectionchange';\n    var TOP_MOUSE_DOWN = 'mousedown';\n    var TOP_MOUSE_MOVE = 'mousemove';\n    var TOP_MOUSE_UP = 'mouseup';\n\n    function isStartish(topLevelType) {\n      return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n    }\n\n    function isMoveish(topLevelType) {\n      return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n    }\n\n    function isEndish(topLevelType) {\n      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n    }\n\n    var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n    var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n    var MAX_TOUCH_BANK = 20;\n    var touchBank = [];\n    var touchHistory = {\n      touchBank: touchBank,\n      numberActiveTouches: 0,\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n\n    function timestampForTouch(touch) {\n      return touch.timeStamp || touch.timestamp;\n    }\n\n    function createTouchRecord(touch) {\n      return {\n        touchActive: true,\n        startPageX: touch.pageX,\n        startPageY: touch.pageY,\n        startTimeStamp: timestampForTouch(touch),\n        currentPageX: touch.pageX,\n        currentPageY: touch.pageY,\n        currentTimeStamp: timestampForTouch(touch),\n        previousPageX: touch.pageX,\n        previousPageY: touch.pageY,\n        previousTimeStamp: timestampForTouch(touch)\n      };\n    }\n\n    function resetTouchRecord(touchRecord, touch) {\n      touchRecord.touchActive = true;\n      touchRecord.startPageX = touch.pageX;\n      touchRecord.startPageY = touch.pageY;\n      touchRecord.startTimeStamp = timestampForTouch(touch);\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchRecord.previousPageX = touch.pageX;\n      touchRecord.previousPageY = touch.pageY;\n      touchRecord.previousTimeStamp = timestampForTouch(touch);\n    }\n\n    function getTouchIdentifier(_ref) {\n      var identifier = _ref.identifier;\n\n      if (!(identifier != null)) {\n        {\n          throw Error(\"Touch object is missing identifier.\");\n        }\n      }\n\n      {\n        !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;\n      }\n      return identifier;\n    }\n\n    function recordTouchStart(touch) {\n      var identifier = getTouchIdentifier(touch);\n      var touchRecord = touchBank[identifier];\n\n      if (touchRecord) {\n        resetTouchRecord(touchRecord, touch);\n      } else {\n        touchBank[identifier] = createTouchRecord(touch);\n      }\n\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    }\n\n    function recordTouchMove(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = true;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function recordTouchEnd(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = false;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n\n    function printTouch(touch) {\n      return JSON.stringify({\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        timestamp: timestampForTouch(touch)\n      });\n    }\n\n    function printTouchBank() {\n      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n      if (touchBank.length > MAX_TOUCH_BANK) {\n        printed += ' (original size: ' + touchBank.length + ')';\n      }\n\n      return printed;\n    }\n\n    var ResponderTouchHistoryStore = {\n      recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n        if (isMoveish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchMove);\n        } else if (isStartish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchStart);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n          }\n        } else if (isEndish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchEnd);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            for (var i = 0; i < touchBank.length; i++) {\n              var touchTrackToCheck = touchBank[i];\n\n              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n                touchHistory.indexOfSingleActiveTouch = i;\n                break;\n              }\n            }\n\n            {\n              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n              !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, 'Cannot find single active touch.') : void 0;\n            }\n          }\n        }\n      },\n      touchHistory: touchHistory\n    };\n\n    function accumulate(current, next) {\n      if (!(next != null)) {\n        {\n          throw Error(\"accumulate(...): Accumulated items must not be null or undefined.\");\n        }\n      }\n\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        return current.concat(next);\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n\n    var responderInst = null;\n    var trackedTouchCount = 0;\n\n    var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {\n      var oldResponderInst = responderInst;\n      responderInst = nextResponderInst;\n\n      if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n      }\n    };\n\n    var eventTypes = {\n      startShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onStartShouldSetResponder',\n          captured: 'onStartShouldSetResponderCapture'\n        },\n        dependencies: startDependencies\n      },\n      scrollShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onScrollShouldSetResponder',\n          captured: 'onScrollShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SCROLL]\n      },\n      selectionChangeShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelectionChangeShouldSetResponder',\n          captured: 'onSelectionChangeShouldSetResponderCapture'\n        },\n        dependencies: [TOP_SELECTION_CHANGE]\n      },\n      moveShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: 'onMoveShouldSetResponder',\n          captured: 'onMoveShouldSetResponderCapture'\n        },\n        dependencies: moveDependencies\n      },\n      responderStart: {\n        registrationName: 'onResponderStart',\n        dependencies: startDependencies\n      },\n      responderMove: {\n        registrationName: 'onResponderMove',\n        dependencies: moveDependencies\n      },\n      responderEnd: {\n        registrationName: 'onResponderEnd',\n        dependencies: endDependencies\n      },\n      responderRelease: {\n        registrationName: 'onResponderRelease',\n        dependencies: endDependencies\n      },\n      responderTerminationRequest: {\n        registrationName: 'onResponderTerminationRequest',\n        dependencies: []\n      },\n      responderGrant: {\n        registrationName: 'onResponderGrant',\n        dependencies: []\n      },\n      responderReject: {\n        registrationName: 'onResponderReject',\n        dependencies: []\n      },\n      responderTerminate: {\n        registrationName: 'onResponderTerminate',\n        dependencies: []\n      }\n    };\n\n    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;\n      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);\n      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n      if (skipOverBubbleShouldSetFrom) {\n        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n      } else {\n        accumulateTwoPhaseDispatches(shouldSetEvent);\n      }\n\n      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n      if (!shouldSetEvent.isPersistent()) {\n        shouldSetEvent.constructor.release(shouldSetEvent);\n      }\n\n      if (!wantsResponderInst || wantsResponderInst === responderInst) {\n        return null;\n      }\n\n      var extracted;\n      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(grantEvent);\n      var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n      if (responderInst) {\n        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminationRequestEvent);\n        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n        if (!terminationRequestEvent.isPersistent()) {\n          terminationRequestEvent.constructor.release(terminationRequestEvent);\n        }\n\n        if (shouldSwitch) {\n          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(terminateEvent);\n          extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n          changeResponder(wantsResponderInst, blockHostResponder);\n        } else {\n          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(rejectEvent);\n          extracted = accumulate(extracted, rejectEvent);\n        }\n      } else {\n        extracted = accumulate(extracted, grantEvent);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      }\n\n      return extracted;\n    }\n\n    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n      return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n    }\n\n    function noResponderTouches(nativeEvent) {\n      var touches = nativeEvent.touches;\n\n      if (!touches || touches.length === 0) {\n        return true;\n      }\n\n      for (var i = 0; i < touches.length; i++) {\n        var activeTouch = touches[i];\n        var target = activeTouch.target;\n\n        if (target !== null && target !== undefined && target !== 0) {\n          var targetInst = getInstanceFromNode$1(target);\n\n          if (isAncestor(responderInst, targetInst)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    var ResponderEventPlugin = {\n      _getResponder: function _getResponder() {\n        return responderInst;\n      },\n      eventTypes: eventTypes,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n        if (isStartish(topLevelType)) {\n          trackedTouchCount += 1;\n        } else if (isEndish(topLevelType)) {\n          if (trackedTouchCount >= 0) {\n            trackedTouchCount -= 1;\n          } else {\n            console.warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n            return null;\n          }\n        }\n\n        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;\n        var isResponderTouchStart = responderInst && isStartish(topLevelType);\n        var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n        var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n        var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n        if (incrementalTouch) {\n          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(gesture);\n          extracted = accumulate(extracted, gesture);\n        }\n\n        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n        var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n        if (finalTouch) {\n          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(finalEvent);\n          extracted = accumulate(extracted, finalEvent);\n          changeResponder(null);\n        }\n\n        return extracted;\n      },\n      GlobalResponderHandler: null,\n      injection: {\n        injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {\n          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n        }\n      }\n    };\n    var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\n    var getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\n    var getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\n    var getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\n    var injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n    setComponentTree(getFiberCurrentPropsFromNode, getInstanceFromNode, getNodeFromInstance);\n    var ReactDOMUnstableNativeDependencies = Object.freeze({\n      ResponderEventPlugin: ResponderEventPlugin,\n      ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n      injectEventPluginsByName: injectEventPluginsByName\n    });\n    var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n    module.exports = unstableNativeDependencies;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}