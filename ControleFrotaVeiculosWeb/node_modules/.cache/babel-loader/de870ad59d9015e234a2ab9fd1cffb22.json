{"ast":null,"code":"var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\n;\n(function () {\n  var isLoader = typeof define === \"function\" && define.amd;\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n  var freeExports = objectTypes[typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)] && exports && !exports.nodeType && exports;\n  var root = objectTypes[typeof window === \"undefined\" ? \"undefined\" : _typeof(window)] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module === \"undefined\" ? \"undefined\" : _typeof(module)] && module && !module.nodeType && (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  function runInContext(context, exports) {\n    context || (context = root.Object());\n    exports || (exports = root.Object());\n    var Number = context.Number || root.Number,\n        String = context.String || root.String,\n        Object = context.Object || root.Object,\n        Date = context.Date || root.Date,\n        SyntaxError = context.SyntaxError || root.SyntaxError,\n        TypeError = context.TypeError || root.TypeError,\n        Math = context.Math || root.Math,\n        nativeJSON = context.JSON || root.JSON;\n\n    if (_typeof(nativeJSON) == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty = objectProto.hasOwnProperty,\n        undefined;\n\n    function attempt(func, errorFunc) {\n      try {\n        func();\n      } catch (exception) {\n        if (errorFunc) {\n          errorFunc();\n        }\n      }\n    }\n\n    var isExtended = new Date(-3509827334573292);\n    attempt(function () {\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    });\n\n    function has(name) {\n      if (has[name] != null) {\n        return has[name];\n      }\n\n      var isSupported;\n\n      if (name == \"bug-string-char-index\") {\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        isSupported = has(\"json-stringify\") && has(\"date-serialization\") && has(\"json-parse\");\n      } else if (name == \"date-serialization\") {\n        isSupported = has(\"json-stringify\") && isExtended;\n\n        if (isSupported) {\n          var stringify = exports.stringify;\n          attempt(function () {\n            isSupported = stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' && stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' && stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' && stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n          });\n        }\n      } else {\n        var value,\n            serialized = \"{\\\"a\\\":[1,true,false,null,\\\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\\\"]}\";\n\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify,\n              stringifySupported = typeof stringify == \"function\";\n\n          if (stringifySupported) {\n            (value = function value() {\n              return 1;\n            }).toJSON = value;\n            attempt(function () {\n              stringifySupported = stringify(0) === \"0\" && stringify(new Number()) === \"0\" && stringify(new String()) == '\"\"' && stringify(getClass) === undefined && stringify(undefined) === undefined && stringify() === undefined && stringify(value) === \"1\" && stringify([value]) == \"[1]\" && stringify([undefined]) == \"[null]\" && stringify(null) == \"null\" && stringify([undefined, getClass, null]) == \"[null,null,null]\" && stringify({\n                \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"]\n              }) == serialized && stringify(null, value) === \"1\" && stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\";\n            }, function () {\n              stringifySupported = false;\n            });\n          }\n\n          isSupported = stringifySupported;\n        }\n\n        if (name == \"json-parse\") {\n          var parse = exports.parse,\n              parseSupported;\n\n          if (typeof parse == \"function\") {\n            attempt(function () {\n              if (parse(\"0\") === 0 && !parse(false)) {\n                value = parse(serialized);\n                parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n\n                if (parseSupported) {\n                  attempt(function () {\n                    parseSupported = !parse('\"\\t\"');\n                  });\n\n                  if (parseSupported) {\n                    attempt(function () {\n                      parseSupported = parse(\"01\") !== 1;\n                    });\n                  }\n\n                  if (parseSupported) {\n                    attempt(function () {\n                      parseSupported = parse(\"1.\") !== 1;\n                    });\n                  }\n                }\n              }\n            }, function () {\n              parseSupported = false;\n            });\n          }\n\n          isSupported = parseSupported;\n        }\n      }\n\n      return has[name] = !!isSupported;\n    }\n\n    has[\"bug-string-char-index\"] = has[\"date-serialization\"] = has[\"json\"] = has[\"json-stringify\"] = has[\"json-parse\"] = null;\n\n    if (!has(\"json\")) {\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      var _forOwn = function forOwn(object, callback) {\n        var size = 0,\n            Properties,\n            dontEnums,\n            property;\n        (Properties = function Properties() {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n        dontEnums = new Properties();\n\n        for (property in dontEnums) {\n          if (isProperty.call(dontEnums, property)) {\n            size++;\n          }\n        }\n\n        Properties = dontEnums = null;\n\n        if (!size) {\n          dontEnums = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n\n          _forOwn = function forOwn(object, callback) {\n            var isFunction = getClass.call(object) == functionClass,\n                property,\n                length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || isProperty;\n\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n\n            for (length = dontEnums.length; property = dontEnums[--length];) {\n              if (hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          _forOwn = function forOwn(object, callback) {\n            var isFunction = getClass.call(object) == functionClass,\n                property,\n                isConstructor;\n\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n\n            if (isConstructor || isProperty.call(object, property = \"constructor\")) {\n              callback(property);\n            }\n          };\n        }\n\n        return _forOwn(object, callback);\n      };\n\n      if (!has(\"json-stringify\") && !has(\"date-serialization\")) {\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n        var leadingZeroes = \"000000\";\n\n        var toPaddedString = function toPaddedString(width, value) {\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        var _serializeDate = function serializeDate(value) {\n          var getData, year, month, date, time, hours, minutes, seconds, milliseconds;\n\n          if (!isExtended) {\n            var floor = Math.floor;\n            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n\n            var getDay = function getDay(year, month) {\n              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n            };\n\n            getData = function getData(value) {\n              date = floor(value / 864e5);\n\n              for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {\n                ;\n              }\n\n              for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {\n                ;\n              }\n\n              date = 1 + date - getDay(year, month);\n              time = (value % 864e5 + 864e5) % 864e5;\n              hours = floor(time / 36e5) % 24;\n              minutes = floor(time / 6e4) % 60;\n              seconds = floor(time / 1e3) % 60;\n              milliseconds = time % 1e3;\n            };\n          } else {\n            getData = function getData(value) {\n              year = value.getUTCFullYear();\n              month = value.getUTCMonth();\n              date = value.getUTCDate();\n              hours = value.getUTCHours();\n              minutes = value.getUTCMinutes();\n              seconds = value.getUTCSeconds();\n              milliseconds = value.getUTCMilliseconds();\n            };\n          }\n\n          _serializeDate = function serializeDate(value) {\n            if (value > -1 / 0 && value < 1 / 0) {\n              getData(value);\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) + \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) + \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              year = month = date = hours = minutes = seconds = milliseconds = null;\n            } else {\n              value = null;\n            }\n\n            return value;\n          };\n\n          return _serializeDate(value);\n        };\n\n        if (has(\"json-stringify\") && !has(\"date-serialization\")) {\n          var dateToJSON = function dateToJSON(key) {\n            return _serializeDate(this);\n          };\n\n          var nativeStringify = exports.stringify;\n\n          exports.stringify = function (source, filter, width) {\n            var nativeToJSON = Date.prototype.toJSON;\n            Date.prototype.toJSON = dateToJSON;\n            var result = nativeStringify(source, filter, width);\n            Date.prototype.toJSON = nativeToJSON;\n            return result;\n          };\n        } else {\n          var unicodePrefix = \"\\\\u00\";\n\n          var escapeChar = function escapeChar(character) {\n            var charCode = character.charCodeAt(0),\n                escaped = Escapes[charCode];\n\n            if (escaped) {\n              return escaped;\n            }\n\n            return unicodePrefix + toPaddedString(2, charCode.toString(16));\n          };\n\n          var reEscape = /[\\x00-\\x1f\\x22\\x5c]/g;\n\n          var quote = function quote(value) {\n            reEscape.lastIndex = 0;\n            return '\"' + (reEscape.test(value) ? value.replace(reEscape, escapeChar) : value) + '\"';\n          };\n\n          var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {\n            var value, type, className, results, element, index, length, prefix, result;\n            attempt(function () {\n              value = object[property];\n            });\n\n            if (_typeof(value) == \"object\" && value) {\n              if (value.getUTCFullYear && getClass.call(value) == dateClass && value.toJSON === Date.prototype.toJSON) {\n                value = _serializeDate(value);\n              } else if (typeof value.toJSON == \"function\") {\n                value = value.toJSON(property);\n              }\n            }\n\n            if (callback) {\n              value = callback.call(object, property, value);\n            }\n\n            if (value == undefined) {\n              return value === undefined ? value : \"null\";\n            }\n\n            type = _typeof(value);\n\n            if (type == \"object\") {\n              className = getClass.call(value);\n            }\n\n            switch (className || type) {\n              case \"boolean\":\n              case booleanClass:\n                return \"\" + value;\n\n              case \"number\":\n              case numberClass:\n                return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n\n              case \"string\":\n              case stringClass:\n                return quote(\"\" + value);\n            }\n\n            if (_typeof(value) == \"object\") {\n              for (length = stack.length; length--;) {\n                if (stack[length] === value) {\n                  throw TypeError();\n                }\n              }\n\n              stack.push(value);\n              results = [];\n              prefix = indentation;\n              indentation += whitespace;\n\n              if (className == arrayClass) {\n                for (index = 0, length = value.length; index < length; index++) {\n                  element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                  results.push(element === undefined ? \"null\" : element);\n                }\n\n                result = results.length ? whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : \"[\" + results.join(\",\") + \"]\" : \"[]\";\n              } else {\n                _forOwn(properties || value, function (property) {\n                  var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n\n                  if (element !== undefined) {\n                    results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                  }\n                });\n\n                result = results.length ? whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : \"{\" + results.join(\",\") + \"}\" : \"{}\";\n              }\n\n              stack.pop();\n              return result;\n            }\n          };\n\n          exports.stringify = function (source, filter, width) {\n            var whitespace, callback, properties, className;\n\n            if (objectTypes[_typeof(filter)] && filter) {\n              className = getClass.call(filter);\n\n              if (className == functionClass) {\n                callback = filter;\n              } else if (className == arrayClass) {\n                properties = {};\n\n                for (var index = 0, length = filter.length, value; index < length;) {\n                  value = filter[index++];\n                  className = getClass.call(value);\n\n                  if (className == \"[object String]\" || className == \"[object Number]\") {\n                    properties[value] = 1;\n                  }\n                }\n              }\n            }\n\n            if (width) {\n              className = getClass.call(width);\n\n              if (className == numberClass) {\n                if ((width -= width % 1) > 0) {\n                  if (width > 10) {\n                    width = 10;\n                  }\n\n                  for (whitespace = \"\"; whitespace.length < width;) {\n                    whitespace += \" \";\n                  }\n                }\n              } else if (className == stringClass) {\n                whitespace = width.length <= 10 ? width : width.slice(0, 10);\n              }\n            }\n\n            return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n          };\n        }\n      }\n\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n        var Index, Source;\n\n        var abort = function abort() {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        var lex = function lex() {\n          var source = Source,\n              length = source.length,\n              value,\n              begin,\n              position,\n              isSigned,\n              charCode;\n\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n\n            switch (charCode) {\n              case 9:\n              case 10:\n              case 13:\n              case 32:\n                Index++;\n                break;\n\n              case 123:\n              case 125:\n              case 91:\n              case 93:\n              case 58:\n              case 44:\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n\n              case 34:\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n\n                  if (charCode < 32) {\n                    abort();\n                  } else if (charCode == 92) {\n                    charCode = source.charCodeAt(++Index);\n\n                    switch (charCode) {\n                      case 92:\n                      case 34:\n                      case 47:\n                      case 98:\n                      case 116:\n                      case 110:\n                      case 102:\n                      case 114:\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n\n                      case 117:\n                        begin = ++Index;\n\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            abort();\n                          }\n                        }\n\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n\n                      default:\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      break;\n                    }\n\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n\n                    value += source.slice(begin, Index);\n                  }\n                }\n\n                if (source.charCodeAt(Index) == 34) {\n                  Index++;\n                  return value;\n                }\n\n                abort();\n\n              default:\n                begin = Index;\n\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n\n                if (charCode >= 48 && charCode <= 57) {\n                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {\n                    abort();\n                  }\n\n                  isSigned = false;\n\n                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {\n                    ;\n                  }\n\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n\n                    for (; position < length; position++) {\n                      charCode = source.charCodeAt(position);\n\n                      if (charCode < 48 || charCode > 57) {\n                        break;\n                      }\n                    }\n\n                    if (position == Index) {\n                      abort();\n                    }\n\n                    Index = position;\n                  }\n\n                  charCode = source.charCodeAt(Index);\n\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n\n                    for (position = Index; position < length; position++) {\n                      charCode = source.charCodeAt(position);\n\n                      if (charCode < 48 || charCode > 57) {\n                        break;\n                      }\n                    }\n\n                    if (position == Index) {\n                      abort();\n                    }\n\n                    Index = position;\n                  }\n\n                  return +source.slice(begin, Index);\n                }\n\n                if (isSigned) {\n                  abort();\n                }\n\n                var temp = source.slice(Index, Index + 4);\n\n                if (temp == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (temp == \"fals\" && source.charCodeAt(Index + 4) == 101) {\n                  Index += 5;\n                  return false;\n                } else if (temp == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n\n                abort();\n            }\n          }\n\n          return \"$\";\n        };\n\n        var get = function get(value) {\n          var results, hasMembers;\n\n          if (value == \"$\") {\n            abort();\n          }\n\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              return value.slice(1);\n            }\n\n            if (value == \"[\") {\n              results = [];\n\n              for (;;) {\n                value = lex();\n\n                if (value == \"]\") {\n                  break;\n                }\n\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n\n                    if (value == \"]\") {\n                      abort();\n                    }\n                  } else {\n                    abort();\n                  }\n                } else {\n                  hasMembers = true;\n                }\n\n                if (value == \",\") {\n                  abort();\n                }\n\n                results.push(get(value));\n              }\n\n              return results;\n            } else if (value == \"{\") {\n              results = {};\n\n              for (;;) {\n                value = lex();\n\n                if (value == \"}\") {\n                  break;\n                }\n\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n\n                    if (value == \"}\") {\n                      abort();\n                    }\n                  } else {\n                    abort();\n                  }\n                } else {\n                  hasMembers = true;\n                }\n\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n\n                results[value.slice(1)] = get(lex());\n              }\n\n              return results;\n            }\n\n            abort();\n          }\n\n          return value;\n        };\n\n        var update = function update(source, property, callback) {\n          var element = walk(source, property, callback);\n\n          if (element === undefined) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        var walk = function walk(source, property, callback) {\n          var value = source[property],\n              length;\n\n          if (_typeof(value) == \"object\" && value) {\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(getClass, _forOwn, value, length, callback);\n              }\n            } else {\n              _forOwn(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n\n          return callback.call(source, property, value);\n        };\n\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n\n          if (lex() != \"$\") {\n            abort();\n          }\n\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports.runInContext = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    runInContext(root, freeExports);\n  } else {\n    var nativeJSON = root.JSON,\n        previousJSON = root.JSON3,\n        isRestored = false;\n    var JSON3 = runInContext(root, root.JSON3 = {\n      \"noConflict\": function noConflict() {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root.JSON3 = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n\n        return JSON3;\n      }\n    });\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}